using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml;
using Microsoft.CodeAnalysis;
using Microsoft.Extensions.Logging;
using Tapper;
using Tapper.TypeMappers;

namespace TypedSignalR.Client.TypeScript;

internal class InterfaceTranspiler
{
    private readonly SpecialSymbols _specialSymbols;
    private readonly ITypedSignalRTranspilationOptions _options;
    private readonly ILogger _logger;

    public InterfaceTranspiler(SpecialSymbols specialSymbols, ITypedSignalRTranspilationOptions options, ILogger logger)
    {
        _specialSymbols = specialSymbols;
        _options = options;
        _logger = logger;
    }

    public IReadOnlyList<GeneratedSourceCode> Transpile(IEnumerable<INamedTypeSymbol> interfaceTypes)
    {
        var typeLookup = interfaceTypes.Distinct<INamedTypeSymbol>(SymbolEqualityComparer.Default)
            .ToLookup<INamedTypeSymbol, INamespaceSymbol>(static x => x.ContainingNamespace, SymbolEqualityComparer.Default);

        var outputSourceCodeList = new List<GeneratedSourceCode>(typeLookup.Count);

        foreach (var group in typeLookup)
        {
            var codeWriter = new CodeWriter();

            AddHeader(group, ref codeWriter);

            foreach (var type in group)
            {
                _logger.Log(LogLevel.Information, "Transpile {typename}...", type.ToDisplayString());

                AddInterface(type, _specialSymbols, _options, ref codeWriter);
            }

            var code = codeWriter.ToString().NormalizeNewLines("\n");

            outputSourceCodeList.Add(new GeneratedSourceCode($"TypedSignalR.Client/{group.Key}.ts", code));
        }

        return outputSourceCodeList;
    }

    private void AddHeader(IGrouping<INamespaceSymbol, INamedTypeSymbol> interfaceTypes, ref CodeWriter codeWriter)
    {
        codeWriter.AppendLine("/* THIS (.ts) FILE IS GENERATED BY TypedSignalR.Client.TypeScript */");
        codeWriter.AppendLine("/* eslint-disable */");
        codeWriter.AppendLine("/* tslint:disable */");
        codeWriter.AppendLine("// @ts-nocheck");
        codeWriter.AppendLine("import { IStreamResult, Subject } from '@microsoft/signalr';");

        var appearTypes = interfaceTypes
            .SelectMany(static x => x.GetMethods())
            .SelectMany(x =>
                x.Parameters
                    .Select(y => y.Type.GetFeaturedType(_specialSymbols))
                    .Concat(new[] { x.ReturnType.GetFeaturedType(_specialSymbols) })
            );

        var tapperAttributeAnnotatedTypesLookup = appearTypes
            .SelectMany(RoslynExtensions.GetRelevantTypes)
            .OfType<INamedTypeSymbol>()
            .Where(x => x.IsAttributeAnnotated(_specialSymbols.TranspilationSourceAttributeSymbols))
            .Distinct<INamedTypeSymbol>(SymbolEqualityComparer.Default)
            .ToLookup<INamedTypeSymbol, INamespaceSymbol>(static x => x.ContainingNamespace, SymbolEqualityComparer.Default);

        foreach (var groupingType in tapperAttributeAnnotatedTypesLookup)
        {
            // Be careful about the directory hierarchy.
            // Tapper generates a file named (namespace).ts directly under the specified directory(e.g. generated/HogeNamespace.ts).
            // TypedSignalR.Client.TypeScript creates a directory named TypedSignalR.Client in the specified directory
            // and generates TypeScript files there. (e.g. generated/TypedSignalR.Client/index.ts)
            // Therefore, in order to refer to the TypeScript file created by Tapper, we have to specify the directory one level up.
            codeWriter.AppendLine($"import {{ {string.Join(", ", groupingType.Select(x => x.Name))} }} from '../{groupingType.Key.ToDisplayString()}';");
        }

        codeWriter.AppendLine();
    }

    private static void AddInterface(
        INamedTypeSymbol interfaceSymbol,
        SpecialSymbols specialSymbols,
        ITypedSignalRTranspilationOptions options,
        ref CodeWriter codeWriter)
    {
        var doc = GetDocumentationComment(interfaceSymbol);
        var summaryList = doc?.GetElementsByTagName("summary");
        var summary = summaryList?.Count > 0 ? summaryList[0]?.InnerText.Trim() : null;

        if (!string.IsNullOrEmpty(summary))
        {
            codeWriter.AppendLine("/**");
            codeWriter.AppendLine($"* {summary}");
            codeWriter.AppendLine($"*/");
        }

        codeWriter.AppendLine($"export type {interfaceSymbol.Name} = {{");

        foreach (var method in interfaceSymbol.GetMethods())
        {
            WriteJSDoc(method, ref codeWriter);
            codeWriter.Append($"    {method.Name.Format(options.MethodStyle)}(");
            WriteParameters(method, options, specialSymbols, ref codeWriter);
            codeWriter.Append("): ");
            WriteReturnType(method, options, specialSymbols, ref codeWriter);
            codeWriter.AppendLine(";");
        }

        codeWriter.AppendLine("}");
        codeWriter.AppendLine();
    }

    private static void WriteJSDoc(IMethodSymbol methodSymbol, ref CodeWriter codeWriter)
    {
        var xmlDocumentation = GetDocumentationComment(methodSymbol);

        codeWriter.AppendLine("    /**");

        if (xmlDocumentation is not null)
        {
            WriteJSDocSummary(xmlDocumentation, ref codeWriter);
        }

        var parameterDocumentations = GetParameterDocumentations(xmlDocumentation);

        foreach (var parameter in methodSymbol.Parameters)
        {
            WriteJSDocParameter(parameter, parameterDocumentations, ref codeWriter);
        }

        WriteJSDocReturn(methodSymbol, xmlDocumentation, ref codeWriter);
        codeWriter.AppendLine("    */");
    }

    private static void WriteJSDocSummary(XmlDocument xmlDocument, ref CodeWriter codeWriter)
    {
        var summaryList = xmlDocument.GetElementsByTagName("summary");

        if (summaryList.Count == 0
            || string.IsNullOrWhiteSpace(summaryList[0]?.InnerText))
        {
            return;
        }

        var summaryLines = summaryList[0]!.InnerText
            .Trim()
            .NormalizeNewLines(Environment.NewLine)
            .Split(Environment.NewLine)
            .Select(x => x.Trim());

        foreach (var summary in summaryLines)
        {
            codeWriter.AppendLine($"    * {summary}");
        }
    }

    private static void WriteJSDocParameter(IParameterSymbol parameter, IReadOnlyDictionary<string, string[]>? parameterDocumentations, ref CodeWriter codeWriter)
    {
        if (parameterDocumentations is null
            || !parameterDocumentations.TryGetValue(parameter.Name, out var parameterDocument)
            || parameterDocument.Length == 0
            || (parameterDocument.Length == 1 && string.IsNullOrWhiteSpace(parameterDocument[0])))
        {
            codeWriter.AppendLine($"    * @param {parameter.Name} Transpiled from {parameter.Type.ToDisplayString()}");
            return;
        }

        if (parameterDocument.Length == 1)
        {
            codeWriter.AppendLine($"    * @param {parameter.Name} {parameterDocument[0]} (Transpiled from {parameter.Type.ToDisplayString()})");
            return;
        }

        // if parameterDocument.Length > 1

        codeWriter.AppendLine($"    * @param {parameter.Name}");

        foreach (var line in parameterDocument)
        {
            codeWriter.AppendLine($"    *     {line}");
        }

        codeWriter.AppendLine($"    *     (Transpiled from {parameter.Type.ToDisplayString()})");
    }

    private static void WriteJSDocReturn(IMethodSymbol methodSymbol, XmlDocument? xmlDocument, ref CodeWriter codeWriter)
    {
        var returnList = xmlDocument?.GetElementsByTagName("returns");

        if (returnList is null
            || returnList.Count == 0
            || string.IsNullOrWhiteSpace(returnList[0]?.InnerText))
        {
            codeWriter.AppendLine($"    * @returns Transpiled from {methodSymbol.ReturnType.ToDisplayString()}");
            return;
        }

        var returnSummaryLines = returnList[0]!.InnerText
            .Trim()
            .NormalizeNewLines(Environment.NewLine)
            .Split(Environment.NewLine)
            .Select(x => x.Trim())
            .ToArray();

        if (returnSummaryLines.Length == 1)
        {
            codeWriter.AppendLine($"    * @returns {returnSummaryLines} (Transpiled from {methodSymbol.ReturnType.ToDisplayString()})");
            return;
        }

        codeWriter.AppendLine($"    * @returns");

        foreach (var line in returnSummaryLines)
        {
            codeWriter.AppendLine($"    *     {line}");
        }

        codeWriter.AppendLine($"    *     (Transpiled from {methodSymbol.ReturnType.ToDisplayString()})");
    }

    private static void WriteParameters(IMethodSymbol methodSymbol, ITranspilationOptions options, SpecialSymbols specialSymbols, ref CodeWriter codeWriter)
    {
        if (methodSymbol.Parameters.Length == 0)
        {
            return;
        }

        if (methodSymbol.Parameters.Length == 1)
        {
            var parameter = methodSymbol.Parameters[0];

            if (SymbolEqualityComparer.Default.Equals(parameter.Type, specialSymbols.CancellationTokenSymbol))
            {
                return;
            }

            codeWriter.Append($"{parameter.Name}: {TypeMapper.MapTo(parameter.Type, options)}");
            return;
        }

        var paramStrings = methodSymbol.Parameters
            .Select(x =>
                SymbolEqualityComparer.Default.Equals(x.Type, specialSymbols.CancellationTokenSymbol)
                    ? null
                    : $"{x.Name}: {TypeMapper.MapTo(x.Type, options)}")
            .Where(x => x is not null);

        codeWriter.Append(string.Join(", ", paramStrings));
    }

    private static void WriteReturnType(
        IMethodSymbol methodSymbol,
        ITranspilationOptions options,
        SpecialSymbols specialSymbols,
        ref CodeWriter codeWriter)
    {
        var returnType = methodSymbol.ReturnType;

        // server-to-client streaming
        if (returnType.IsGenericType())
        {
            // IAsyncEnumerable<T>, ChannelReader<T>
            //     if parameter type -> Subject<T>
            //     if return type    -> IStreamResult<T>
            // TypeMapper.MapTo
            //     IAsyncEnumerable<T> -> Subject<T>
            //     ChannelReader<T>    -> Subject<T>

            // Support return type as streaming
            //     IAsyncEnumerable<T>
            //     Task<IAsyncEnumerable<T>>
            //     Task<ChannelReader<T>>

            // IAsyncEnumerable<T>
            if (SymbolEqualityComparer.Default.Equals(returnType.OriginalDefinition, specialSymbols.AsyncEnumerableSymbol))
            {
                var typeArg = ((INamedTypeSymbol)returnType).TypeArguments[0];
                codeWriter.Append($"IStreamResult<{TypeMapper.MapTo(typeArg, options)}>");
                return;
            }

            // Task<IAsyncEnumerable<T>>
            // Task<ChannelReader<T>>
            if (SymbolEqualityComparer.Default.Equals(returnType.OriginalDefinition, specialSymbols.GenericTaskSymbol))
            {
                var typeArg = ((INamedTypeSymbol)returnType).TypeArguments[0];

                if (typeArg.IsGenericType() && typeArg is INamedTypeSymbol namedTypeArg)
                {
                    // IAsyncEnumerable<T> or ChannelReader<T>
                    if (SymbolEqualityComparer.Default.Equals(namedTypeArg.OriginalDefinition, specialSymbols.AsyncEnumerableSymbol)
                        || SymbolEqualityComparer.Default.Equals(namedTypeArg.OriginalDefinition, specialSymbols.ChannelReaderSymbol))
                    {
                        var typeArg2 = namedTypeArg.TypeArguments[0];

                        codeWriter.Append($"IStreamResult<{TypeMapper.MapTo(typeArg2, options)}>");
                        return;
                    }
                }
            }
        }

        codeWriter.Append(TypeMapper.MapTo(returnType, options));
    }

    private static XmlDocument? GetDocumentationComment(ISymbol symbol)
    {
        var documentationComment = symbol.GetDocumentationCommentXml();

        if (string.IsNullOrEmpty(documentationComment))
        {
            return null;
        }

        try
        {
            var xmlDocument = new XmlDocument();
            xmlDocument.LoadXml(documentationComment);
            return xmlDocument;
        }
        catch
        {
            return null;
        }
    }

    private static IReadOnlyDictionary<string, string[]>? GetParameterDocumentations(XmlDocument? xmlDocument)
    {
        if (xmlDocument is null)
        {
            return null;
        }

        return xmlDocument
            .GetElementsByTagName("param")
            .OfType<XmlElement>()
            .ToDictionary(
                x => x.GetAttribute("name"),
                x => x.InnerText
                    .Trim()
                    .NormalizeNewLines(Environment.NewLine)
                    .Split(Environment.NewLine)
                    .Select(x => x.Trim())
                    .ToArray()
            );
    }
}
